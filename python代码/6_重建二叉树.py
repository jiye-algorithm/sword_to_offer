'''输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。'''# -*- coding:utf-8 -*-class TreeNode:    def __init__(self, x):        self.val = x        self.left = None        self.right = None        pass    passclass Solution:    # 返回构造的TreeNode根节点    def reConstructBinaryTree(self, pre, tin):        # write code here        if pre == None or tin == None or pre == [] or tin == []:            return None        # 根节点        node = TreeNode(pre[0])        # 如果只有一个元素，则表示是一个叶节点        if len(tin) != 1:            # 查找前序的根节点到中序中的下标            try:                index = tin.index(node.val)            except:                raise("前序遍历和中序遍历树不匹配")            # 左子树            node.left = self.reConstructBinaryTree(pre[1 : index+1], tin[:index])            # 右子树            node.right = self.reConstructBinaryTree(pre[index + 1:], tin[index + 1:])        return node        pass    passif __name__ == '__main__':    '''    测试用例：        * 输入为NUll        * 空树        * 完整树    '''    '''    参考书建议用例：        * 普通二叉树（完全二叉树， 不完全二叉树）        * 特殊二叉树（所有节点都没有左子树，所有节点都没有右子树，只有一个节点的二叉树）        * 特殊输入测试（二叉树根节点为NULL，输入的前序和中序遍历不匹配）    '''    # *完整树    pre_order = list([1, 2, 4, 7, 3, 5, 6, 8])    mid_order = list([4, 7, 2, 1, 5, 3, 8, 6])    solution = Solution()    result = solution.reConstructBinaryTree(pre_order, mid_order)    print()    pass