'''输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。链接：https://www.nowcoder.com/questionTerminal/b736e784e3e34731af99065031301bca1. 按先序遍历把当前节点cur的左孩子依次入栈同时保存当前节点，每次更新当前路径的和sum；2. 判断当前节点是否是叶子节点以及sum是否等于expectNumber，如果是，把当前路径放入结果中。3. 遇到叶子节点cur更新为NULL，此时看栈顶元素，如果栈顶元素的把栈顶元素保存在last变量中，同时弹出栈顶元素，当期路径中栈顶元素弹出，sum减掉栈顶元素，这一步骤不更改cur的值；4. 如果步骤3中的栈顶元素的右孩子存在且右孩子之前没有遍历过，当前节点cur更新为栈顶的右孩子，此时改变cur=NULL的情况。'''class TreeNode:    def __init__(self, x):        self.val = x        self.left = None        self.right = None        passclass Solution:    def __init__(self):        self.path = []        pass    # 返回二维列表，内部每个列表表示找到的路径    def FindPath(self, root, expectNumber):        path = []        sum = 0        self._find_path(root, expectNumber, sum, path)        return self.path    def _find_path(self, root, except_number, sum, path):        # 将当前节点加入路径        path.append(root.val)        # 到目前节点为止的值        sum += root.val        # 必须是叶节点        if except_number == sum and not root.left and not root.right:            self.path.append([i for i in path])        # 从左子树开始寻找        if root.left:            self._find_path(root.left, except_number, sum, path)        # 从右子树开始寻找        if root.right:            self._find_path(root.right, except_number, sum, path)        # 将当前节点从路径中剔除        sum -= root.val        path.pop(-1)        pass    pass