'''输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。'''# -*- coding:utf-8 -*-class Solution1:    def NumberOf2(self, n):        '''        可以认为使用补码表示的        [(n >> i) for i in range(32)] 的结果如下        [-9, -5, -3, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]        在位操作用负数转化为补码形式，然后展示的时候再转换为原码        '''        # 特殊输入        if n == 0 or n == 1:            return n        # 这里假设了int是32为， 这样只需要移动32次，然后最后一位与1与运算，就可以得出最后一位是什么；        return sum([(n >> i & 1) for i in range(32)])        pass    # 最优，但这里有问题的方案    def NumberOf1(self, n):        '''        书中的最优解法，整数中有几个1就循环几次，        -1之后，最后一个1变为0，无论如何都会这样， 但1之后为可能变为1， 所以需要 &        在这里行不通，根据测试 -9 >> 2之后的结果是 -3 也就是在这里，符号为不变其它位移动，补0                本方法适用于使用原码表示的运算，python利用补码表示负数，        '''        # 非法输入        if not isinstance(n, int):            raise print("错误输入 {}".format(n))        # 特殊输入        if n == 0 or n == 1:            return n        result = 0        while n:            result += 1            n = (n - 1) & n        return result        pass    pass# 输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。def test1():    '''    测试用例：        * 正常输入（正数，负数）        * 特殊输入 0        * 错误输入（非数字）    '''    '''    书中测试用例：        * 正数：（包括边界 1， 0x7FFFFFFF）        * 负数：（包括边界0x80000000, 0xFFFFFFFF）        * 0    '''    print(Solution1().NumberOf1(-9))    pass'''数值的整数次方'''class Solution2:    '''    给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。    '''    def Power(self, base, exponent):        if self._equal(base, 0.0) and exponent < 0:            raise("输入错误")        abs_exponent = abs(exponent)        result = self._power_with_insigned_exponent(base, abs_exponent)        if exponent < 0:            result = 1.0 / result        return result        pass    def _equal(self, num1, num2):        if num1 - num2 > -0.00000001 and num1 - num2 < 0.00000001:            return True        return False    def _power_with_insigned_exponent(self, base, exponent):        if exponent == 0:            return 1        if exponent == 1:            return base        # 递归调用， 感觉还会慢，应该使用循环        result = self._power_with_insigned_exponent(base, exponent >> 1)        result *= result        # 位运算，这样快速        if exponent & 1 == 1:            result *= base        return result        pass    passif __name__ == '__main__':    Solution2().Power(0.0, -2)    pass