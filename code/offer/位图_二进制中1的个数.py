'''输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。'''# -*- coding:utf-8 -*-class Solution1:    def NumberOf2(self, n):        '''        可以认为使用补码表示的        [(n >> i) for i in range(32)] 的结果如下        [-9, -5, -3, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]        在位操作用负数转化为补码形式，然后展示的时候再转换为原码        '''        # 特殊输入        if n == 0 or n == 1:            return n        # 这里假设了int是32位， 这样只需要移动32次，然后最后一位与1与运算，就可以得出最后一位是什么；        return sum([(n >> i & 1) for i in range(32)])    # 最优，但这里有问题的方案    def NumberOf1(self, n):        '''        书中的最优解法，整数中有几个1就循环几次，        -1之后，最后一个1变为0，无论如何都会这样， 但1之后为可能变为1， 所以需要 &        在这里行不通，根据测试 -9 >> 2之后的结果是 -3 也就是在这里，符号为不变其它位移动，补0                本方法适用于使用原码表示的运算，python利用补码表示负数，        '''        # 非法输入        if not isinstance(n, int):            raise print("错误输入 {}".format(n))        # 特殊输入        if n == 0 or n == 1:            return n        result = 0        while n:            result += 1            n = (n - 1) & n        return result    pass# 输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。def test1():    '''    测试用例：        * 正常输入（正数，负数）        * 特殊输入 0        * 错误输入（非数字）    '''    '''    书中测试用例：        * 正数：（包括边界 1， 0x7FFFFFFF）        * 负数：（包括边界0x80000000, 0xFFFFFFFF）        * 0    '''    print(Solution1().NumberOf1(-9))    passif __name__ == '__main__':    Solution2().Power(0.0, -2)    pass